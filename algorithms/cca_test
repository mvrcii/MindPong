import matplotlib.pyplot as plt
import numpy as np
import cursor_online_control
from config import CONFIG
from data.datasets.datasets import DATASETS

# GLOBAL DATA
DATASTREAM = None
LABELSTREAM = list()
plot_data = list()
plot_label = list()
num_used_channels = 0
'''
Sliding window size: 
    1 -> 200ms
    2 -> 400ms
    ...
    5 -> 1s
'''
sliding_window_size_factor = 5


def loadBCICDataset(ch_weight):
    # Load BCIC dataset
    dataset = DATASETS['BCIC']
    used_subjects = [2]
    validation_subjects = []
    n_class = 2
    ch_names = dataset.CONSTANTS.CHANNELS
    used_ch_names = []
    for i in range(len(ch_names)):
        if ch_weight[i] != 0:
            if ch_names[i] == 'C3':
                used_ch_names.insert(0, ch_names[i])
            elif ch_names[i] == 'C4':
                used_ch_names.insert(1, ch_names[i])
            else:
                used_ch_names.append(ch_names[i])
    global num_used_channels
    num_used_channels = len(used_ch_names)
    ds_tmin = -2
    ds_tmax = 5.5

    CONFIG.set_eeg_config(dataset.CONSTANTS.CONFIG)  # Data set specific default initialization
    CONFIG.EEG.set_times(ds_tmin, ds_tmax, dataset.CONSTANTS.CONFIG.CUE_OFFSET)

    print("  - ds_tmin, ds_tmax =", ds_tmin, ds_tmax)
    loaded_data, loaded_labels = dataset.load_subjects_data(used_subjects + validation_subjects, n_class, used_ch_names)
    return loaded_data, loaded_labels, used_ch_names


def slice_array(array):
    """
    Slices a trial into sliding windows with a size of 200ms
    :param array: trial
    :return: small slices of data
    """
    # 100ms = 25 samples; 200ms = 50 samples; ... ; 1s -> 250samples
    slices = list()
    sliding_window_size = sliding_window_size_factor * 25
    for i in range(int(len(array)/sliding_window_size)):
        index = i * sliding_window_size
        slices.append(array[index:index + sliding_window_size])
    return slices


def calculate_sliding_windows(data, labels):
    global DATASTREAM
    DATASTREAM = [[] for _ in range(num_used_channels)]
    sliding_window_size = sliding_window_size_factor * 25
    for i in range(0, 144):
        for j in range(num_used_channels):
            DATASTREAM[j] += slice_array(data[0][i][j][:])

        num_sliding_windows_label = (1875/sliding_window_size)
        for a in range(int(num_sliding_windows_label*0.4)):
            LABELSTREAM.append(None)
        for b in range(int(num_sliding_windows_label*0.4)):
            LABELSTREAM.append(labels[0][i])
        for c in range(int(num_sliding_windows_label*0.2)):
            LABELSTREAM.append(None)


def test_algorithm():
    """
    Calls the algorithm function and tries to plot the data
    :return: None
    """
    counter = 0
    accuracy = 0
    undefined = 0.3
    num_valid_sliding_windows = 0
    while counter < int(1875/(25*sliding_window_size_factor))*144 - 1:
        samples = []
        for i in range(num_used_channels):
            current_samples1 = DATASTREAM[:][i][counter]
            current_samples2 = DATASTREAM[:][i][counter + 1]
            sample = np.concatenate([current_samples1, current_samples2])
            samples.append(sample)

        normalized_hcon = cursor_online_control.perform_algorithm(samples)
        print(f'{counter}: {normalized_hcon}')

        if normalized_hcon > undefined:
            calculated_label = 0
        elif normalized_hcon < -undefined:
            calculated_label = 1
        else:
            calculated_label = -1

        if LABELSTREAM[counter] is not None:
            num_valid_sliding_windows += 1
            plot_data.append(calculated_label)
            plot_label.append(LABELSTREAM[counter])
            if calculated_label == LABELSTREAM[counter]:
                accuracy += 1

        counter += 1

    accuracy /= num_valid_sliding_windows
    print(f'Accuracy = {accuracy}')
    plt.plot(plot_data, 'r')
    plt.plot(plot_label, 'b')
    plt.show()


# def doPlot():
#     # See: https://www.geeksforgeeks.org/matplotlib-animation-funcanimation-class-in-python/
#     fig, ax = plt.subplots(figsize=(8, 6))
#     ax = plt.axes(xlim=(0, 144), ylim=(-500, 500))
#     line, = ax.plot([], [], lw=2)
#     xdata, ydata = [], []
#
#     def funcAnimation(i):
#         global animation_func_var
#         animation_func_var += 1
#         try:
#             hcon = q.get_nowait()
#         except:
#             return
#         xdata.append(animation_func_var)
#         ydata.append(hcon)
#         line.set_data(xdata, ydata)
#         return line,
#
#     ani = FuncAnimation(fig, funcAnimation, frames=2, interval=40)
#     plt.show()

if __name__ == '__main__':
    #                 Fz  FC3  FC1  FCz  FC2  FC4  C5  C3  C1  Cz  C2  C4  C6  CP3  CP1  CPz  CP2  CP4  P1  Pz  P2  POz
    ch_names_weight = [0,  1,   1,   1,   1,   1,   1,  1,  1,  1,  1,  1,  1,  1,   1,   1,   1,   1,   0,  0,  0,  0]
    preloaded_data, preloaded_labels, used_channels = loadBCICDataset(ch_names_weight)
    calculate_sliding_windows(preloaded_data, preloaded_labels)
    test_algorithm()

